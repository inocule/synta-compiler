.PHONY: build clean test lex parse all

# Build both executables
build:
	go build -o bin/synta-lex ./cmd/synta-lex
	go build -o bin/synta-parse ./cmd/synta-parse
	@echo "Built: bin/synta-lex and bin/synta-parse"

# Clean build artifacts
clean:
	rm -rf bin/
	rm -f tokens.json parse-tree.txt ast.json lex-errors.txt parse-errors.txt parse-debug.txt

# Run lexer
lex:
	@if [ -z "$(FILE)" ]; then \
		echo "Usage: make lex FILE=input.synta"; \
		exit 1; \
	fi
	./bin/synta-lex -input $(FILE) -output tokens.json -errors lex-errors.txt

# Run parser
parse:
	./bin/synta-parse -input tokens.json -tree parse-tree.txt -ast ast.json -errors parse-errors.txt -debug parse-debug.txt

# Full pipeline
all: build
	@if [ -z "$(FILE)" ]; then \
		echo "Usage: make all FILE=input.synta"; \
		exit 1; \
	fi
	@echo "Running lexical analysis..."
	./bin/synta-lex -input $(FILE) -output tokens.json -errors lex-errors.txt
	@echo "\nRunning syntax analysis..."
	./bin/synta-parse -input tokens.json -tree parse-tree.txt -ast ast.json -errors parse-errors.txt -debug parse-debug.txt
	@echo "\nDone! Check the output files."

# Test with sample file
test: build
	@echo "=== Testing with sample.synta ==="
	@echo 'Creating test file...'
	@echo 'bind x := 42;' > test.synta
	@echo 'bind y := x + 10;' >> test.synta
	@echo 'print(x, y);' >> test.synta
	@echo ''
	@echo '=== Running lexer ==='
	./bin/synta-lex -input test.synta -output tokens.json -errors lex-errors.txt
	@echo ''
	@echo '=== Running parser ==='
	./bin/synta-parse -input tokens.json -tree parse-tree.txt -ast ast.json -errors parse-errors.txt -debug parse-debug.txt
	@echo ''
	@echo '=== Parse Tree ==='
	@cat parse-tree.txt
	@echo ''
	@echo '=== Files generated ==='
	@ls -lh tokens.json parse-tree.txt ast.json parse-debug.txt
